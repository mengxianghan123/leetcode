## 1.题目
假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。  
请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。  

示例 1：  
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]  
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]  
解释：  
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。  
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。  
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。  
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。  
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。  
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。  
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。  

示例 2：  
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]  
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]  

提示：  
1 <= people.length <= 2000  
0 <= hi <= 106  
0 <= ki < people.length  
题目数据确保队列可以被重建  

---

## 2.分析
拿到这个题，我觉得如果不排序看看，也不知道能有什么别的办法。  
我想到的是把身高从高到低排序。这样的话，拿到一个人，已经排好的人都比他高，后面没来的人都比他矮。那么，我现在前面有几个比我高的，岂不是最后也是这几个人。因此，假如有n个比他高的，我就把排到第n+1个就行了。  
特殊情况，对于一样高的两个人，应该先排谁？先排靠后的人，那么等靠前的人夹进来，就会改变靠后的那个人的比他高的人的数量。如果先排靠前的人，就一切照旧了。  
这个思路我认为较直接，不怎么绕，比较好想到。  

官方题解还提供了另一种思路，把身高由低到高排序。这样的话，拿到一个人，前面排好的人都比他矮，未来的人都比他高。  
后面该咋办？有几个人比我高，我就预留几个位置就行了。  
特殊情况，对于一样高的两个人，应该先排谁？先排靠前的人，那对于靠后的人来说，还是会给靠前的人预留出一个位置，但是靠前的人其实已经占了位置，因此就会出现错误。如果先排靠后的人，就一切照旧了。  

其实这两种思路，有一个微妙的区别。前者是靠“插入”，向量逐渐变长；后者是直接进入最终位置，向量长度固定。  
这是由算法本身的区别带来的，可以好好体会一下！  

---

## 3.其它
1）在排序时，我的写法比官方题解啰嗦，官方题解巧用逻辑运算的先后顺序完成我的if条件语句的效果，值得学习  
2）[vector的多种insert()用法](https://blog.csdn.net/wcc27857285/article/details/77855196?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161216831916780269838567%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161216831916780269838567&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-77855196.pc_search_result_before_js&utm_term=vector%25E9%2580%2589%25E6%258B%25A9%25E6%258F%2592%25E5%2585%25A5%25E4%25BD%258D%25E7%25BD%25AE)