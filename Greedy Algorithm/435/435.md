## 1.题目  
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。  

注意:  
可以认为区间的终点总是大于它的起点。  
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。  

示例 1:  
输入: [ [1,2], [2,3], [3,4], [1,3] ]  
输出: 1  
解释: 移除 [1,3] 后，剩下的区间没有重叠。  

示例 2:  
输入: [ [1,2], [1,2], [1,2] ]  
输出: 2  
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。  

示例 3:  
输入: [ [1,2], [2,3] ]  
输出: 0  
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。  

---

## 2.思路
拿到题目，会有想把区间 ***排序*** 的直觉。但是依据什么排序，排序之后的逻辑是什么，得深入思考，拿出纸笔画一画。  
一个区间的尾值越小，留给后面区间空白的部分越大，越不容易重叠。因此，按照区间尾值大小排序。  
如果一个区间与前面区间发生重叠，就把这个区间去除。  

---

## 3.分析
为了消除重叠，可以有两种选择，一个是去除尾值小的区间，一个是去除尾值大的区间。对于后续区间而言，与后者重叠不一定与前者重叠，而与前者重叠必定与后者重叠。因此，去除尾值大的，可以更好地规避重叠。  

---

## 4.注意事项
如果需要在向量中用到多个迭代器，更要注意： ***向量元素个数极小*** 的情况。比如空列表，只含1个元素的列表。  

---

## 5.扩展
[algorithm中sort()的第3个参数理解](https://blog.csdn.net/qq_34489443/article/details/86219772?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161181288116780266246868%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=161181288116780266246868&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-86219772.first_rank_v2_pc_rank_v29&utm_term=c%252B%252B+sort%25E5%2587%25BD%25E6%2595%25B0)  
[C++匿名函数](https://blog.csdn.net/zhang14916/article/details/101058089?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161181173416780261994958%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=161181173416780261994958&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-101058089.first_rank_v2_pc_rank_v29&utm_term=c%252B%252B%25E5%258C%25BF%25E5%2590%258D%25E5%2587%25BD%25E6%2595%25B0)