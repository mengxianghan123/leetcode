## 1.题目
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。  

示例：  
输入：S = "ababcbacadefegdehijhklij"  
输出：[9,7,8]  
解释：  
划分结果为 "ababcbaca", "defegde", "hijhklij"。  
每个字母最多出现在一个片段中。  
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。  

提示：  
S的长度在[1, 500]之间。  
S只包含小写字母 'a' 到 'z' 。  

---

## 2.分析
拿到这个题我最开始没有想法，但是看到官方题解里说：“显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段”，突然觉得可以把每个字母的出现区间求出，这样问题就转化为：多个区间分组，使各组区间不重叠。  
此问题感觉与之前涉及的区间问题非常相像，因此采用排序，遍历，查重叠的方式。  
这种方法感觉还行，但是提交之后复杂度排名有点垃圾，因此学习了官方题解的方法。  

感觉这种问题直觉上可以通过一次遍历解决，假如我们知道每个字母最后出现的位置，那么遍历字符串，对于每个字符，其最后出现的位置限制了区间结束的最小位置，因此遍历过程中，不断的对“区间结束的位置”求max。  
何时结束呢？当遍历的字符与区间结束位置重叠，意味着对之前区间里的字符，其最后出现的位置都在区间里了，是满足题目要求的。  
由于输出的向量中的元素是区间中元素的数量，因此遍历时，除了记录终点，还需记录起点。  

---

## 3.注意事项
解题过程中出现了两个问题，记录一下：  
&emsp;1）倒序遍历字符串时，我采用的语句是：`for(auto i = S.size() - 1; i >= 0; --i)` 然后发现程序停不下来。这就是因为S.size()返回的类型为无符号类型，减到0后再继续减依旧是正数。因此可以改为：`for(int i = S.size() - 1; i >= 0; --i)`  
&emsp;2）删除元素要谨慎。这是第n次因为删除向量中的元素，而后又按原有的idx去访问向量中的元素，导致bug。  
&emsp;3）在一行语句中定义多个变量的正确方式：`int a = 0, b = 0;` 受到Python影响，写成了`int a, b = 0;` 这样定义带来的后果就是，由于是在函数体内，a被定义为了不确定大小的值。在之后访问到a时，就产生了不可预知的后果。

---

## 4.相关拓展
[C++中检查vector是否包含给定元素的几种方式](https://blog.csdn.net/luoyayun361/article/details/108009585?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161208356016780255284453%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=161208356016780255284453&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-108009585.pc_search_result_before_js&utm_term=C%252B%252B+vector%25E4%25B8%25AD%25E5%258C%2585%25E5%2590%25AB%25E6%259F%2590%25E4%25B8%25AA%25E5%2585%2583%25E7%25B4%25A0)