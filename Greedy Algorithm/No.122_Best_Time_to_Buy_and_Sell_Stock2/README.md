## 1.题目
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。  
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。  
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。  

示例 1:  
输入: [7,1,5,3,6,4]  
输出: 7  
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3。  

示例 2:  
输入: [1,2,3,4,5]  
输出: 4  
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。  

示例 3:  
输入: [7,6,4,3,1]  
输出: 0  
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。  

提示：  
1 <= prices.length <= 3 * 10 ^ 4  
0 <= prices[i] <= 10 ^ 4  

---

## 2.分析
感觉这个题“贪心”的思想体现在，对于每一个位置，只要股票在涨就计入交易，只要在跌就不交易。  
对于每个交易区间，确定“开始”与“结束”即可得到成交的金额。因此直觉上，这种问题双指针都可以搞定。  
但是官方题解的巧妙之处，在于发现了： ***对于一个涨的区间，算整体收益，或是分段算收益，都是一样的。***  
因此，其实双指针都不需要。因为双指针包含了区间头尾的位置信息，而此时不需要此位置信息。只需要遍历整个序列，对于在跌的，不计算收益，对于在涨的，加上收益，就完事了。  
这个思路有了之后，如果让我写，肯定是个if条件判断：
```
if(prices[i+1] > prices[i]) {
	ans += prices[i+1] - prices[i];
	++i;
}else{
	++i;
}
```
但是，官方题解一行代码: `ans += max(0, prices[i] - prices[i - 1])`  
值得借鉴和学习！

---

## 3.其它
这题貌似是动态规划的经典问题，后面学到了再回来看。