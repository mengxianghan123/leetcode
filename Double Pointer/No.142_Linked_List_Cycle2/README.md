## 1.题目
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。  
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。  
说明：不允许修改给定的链表。  

进阶：  
你是否可以使用 O(1) 空间解决此题？  

示例 1：  
输入：head = [3,2,0,-4], pos = 1  
输出：返回索引为 1 的链表节点  
解释：链表中有一个环，其尾部连接到第二个节点。  

示例 2：  
输入：head = [1,2], pos = 0  
输出：返回索引为 0 的链表节点  
解释：链表中有一个环，其尾部连接到第一个节点。  

示例 3：  
输入：head = [1], pos = -1  
输出：返回 null  
解释：链表中没有环。  

提示：  
链表中节点的数目范围在范围 [0, 104] 内  
-105 <= Node.val <= 105  
pos 的值为 -1 或者链表中的一个有效索引  

---

## 2.思路
这个题，常规思路就是，遍历链表，遇到地址重复的就返回重复地址，遇到空就返回空。  
这个方法也是对应的官方题解的方法一，只是采用哈希表的数据结构进行存储，应该可以享受更好的时间复杂度。  

官方题解的方法二采用的是快慢指针，《Leetcode101》作者说 ***对于链表找环路的问题，有一个通用的解法——快慢指针（Floyd 判圈法）***  
具体来讲，首先让快指针与慢指针都指向头结点，之后快指针一次走两步，慢指针一次走一步，当碰头时，让快指针指向头结点。此时开始，快慢指针都是一次走一步，相遇的位置即为圈的起点。  
这个算法从代数或者画图角度都很好证明，但是很难想到，因此需要积累起来！  

---

## 3.其它
&emsp;1）可以积累下常用到的运算符的优先级，比如下面这行代码就不需要打括号：`if (!fast || !fast->next) return nullptr;`  
&emsp;2）Leetcode对于链表节点的定义是个结构体类型，关于[结构体的构造函数](https://blog.csdn.net/vir_lee/article/details/81106049)  
&emsp;3）有关C++的Hash表数据结构 [unordered_set](https://blog.csdn.net/zhang14916/article/details/100859487)  
&emsp;4）有关[链表的一些基本操作](https://blog.csdn.net/chent86/article/details/64503747)