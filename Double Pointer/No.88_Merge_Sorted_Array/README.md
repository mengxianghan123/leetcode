## 1.题目
给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。  
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。  

示例 1：  
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3  
输出：[1,2,2,3,5,6]  

示例 2：  
输入：nums1 = [1], m = 1, nums2 = [], n = 0  
输出：[1]  

提示：  
nums1.length == m + n  
nums2.length == n  
0 <= m, n <= 200  
1 <= m + n <= 200  
-109 <= nums1[i], nums2[i] <= 109  

---

# 2.分析
先说下我自己的方法吧：  
用两个指针分别遍历序列，那么，当nums2的一个数大于nums1的前一个值，却小于nums1的当前值，该数就应该插在这里。  
插入之后自然双指针都向后移动，不满足插入条件就只移动nums1的指针。  
循环截止条件：要么nums1序列遍历完了，那剩下的nums2序列直接放到nums1最后；要么nums2遍历完了，那任务完成。  
这个写法有一个小问题，频繁的插入操作应该复杂度不低，能否避免插入删除的操作呢？  

官方题解提供了一种思路：  
还是双指针分别指向两序列头，每次拿取两序列最小元素，放到结果序列中，被选择的元素对应的指针后移。  
这样就避免了插入操作了，注意，实现是通过指针后移来遍历序列的，而不是通过删除头元素，每次再取头元素。  

当然，这样实现的缺点是，还需要另占用一个结果序列的空间，官方题解还提供了一种倒序遍历的思路，就直接使用nums1当结果序列，而且写入的元素并不会覆盖到未遍历过的元素，非常巧妙，值得学习！  

---

# 3.其它
分享一下Leetcode101作者给的代码，看这种代码简直是享受！
```
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
	int pos = m-- + n-- - 1;
	while (m >= 0 && n >= 0) {
		nums1[pos--] = nums1[m] > nums2[n]? nums1[m--]: nums2[n--];
	}
	while (n >= 0) {
		nums1[pos--] = nums2[n--];
	}
}
```