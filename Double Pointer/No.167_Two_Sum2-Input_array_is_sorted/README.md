## 1.题目
给定一个已按照升序排列的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。  
函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。  
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。  

示例 1：  
输入：numbers = [2,7,11,15], target = 9  
输出：[1,2]  
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。  

示例 2：  
输入：numbers = [2,3,4], target = 6  
输出：[1,3]  

示例 3：  
输入：numbers = [-1,0], target = -1  
输出：[1,2]  

提示：  
2 <= numbers.length <= 3 * 104  
-1000 <= numbers[i] <= 1000  
numbers 按递增顺序排列  
-1000 <= target <= 1000  
仅存在一个有效答案  

---

## 2.分析
第一反应是暴力法。依次遍历所有元素，然后在剩余的数中搜索target-num[1]  
但是在应用暴力法的时候，我忽略了一个条件，就是序列是排序好的，这样的话，搜索不应采用find函数，而是二分查找。  

后面我一直在想，双指针怎么用在这道题中，突然想到，如果两指针一头一尾，当求和结果比目标大时，不论怎么移动头指针，都只会使结果更大，此时只能向左移动尾指针，再将头指针置0。但是后面发现，头指针并不需要置0，感觉非常神奇，难道不担心错过正确答案吗？这里官方题解的解释非常好，[引用一下](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-by-leet-2/)：
```
使用双指针的实质是缩小查找范围。那么会不会把可能的解过滤掉？答案是不会。假设 numbers[i]+numbers[j]=target 是唯一解，其中 0≤i<j≤numbers.length−1。初始时两个指针分别指向下标 0 和下标 numbers.length−1，左指针指向的下标小于或等于 i，右指针指向的下标大于或等于 j。除非初始时左指针和右指针已经位于下标 i 和 j，否则一定是左指针先到达下标 i 的位置或者右指针先到达下标 j 的位置。
如果左指针先到达下标 i 的位置，此时右指针还在下标 j 的右侧，sum>target，因此一定是右指针左移，左指针不可能移到 i 的右侧。
如果右指针先到达下标 j 的位置，此时左指针还在下标 i 的左侧，sum<target，因此一定是左指针右移，右指针不可能移到 j 的左侧。
由此可见，在整个移动过程中，左指针不可能移到 i 的右侧，右指针不可能移到 j 的左侧，因此不会把可能的解过滤掉。由于题目确保有唯一的答案，因此使用双指针一定可以找到答案。
```