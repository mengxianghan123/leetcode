## 1.题目
给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。  
进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？  

示例 1：  
输入：nums1 = [1,3], nums2 = [2]  
输出：2.00000  
解释：合并数组 = [1,2,3] ，中位数 2  

示例 2：  
输入：nums1 = [1,2], nums2 = [3,4]  
输出：2.50000  
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5  

示例 3：  
输入：nums1 = [0,0], nums2 = [0,0]  
输出：0.00000  

示例 4：  
输入：nums1 = [], nums2 = [1]  
输出：1.00000  

示例 5：  
输入：nums1 = [2], nums2 = []  
输出：2.00000  

提示：  
nums1.length == m  
nums2.length == n  
0 <= m <= 1000  
0 <= n <= 1000  
1 <= m + n <= 2000  
-106 <= nums1[i], nums2[i] <= 106  

---

## 2.分析
这道题二分的思路感觉和之前碰到的题不太一样。此题如果直接去解，可能采用的一种方式是，双指针遍历两序列，逐一判断较小值，移动相应的指针。那么，此时二分法用来加速的过程，就是两指针后移的过程。能否更快速的后移指针，每次后移确保指针越过的值都不可能是两序列的中位数。  
题解便是从这个角度出发，想出了一种办法，使得指针快速后移，且越过的值都不可能是两序列的中位数。  
若要找到两序列第k小的值，便去观察两序列各自的第k/2个值（从1起），进行比较，对于较小的那个值，它所在序列的前k/2-1个值肯定比它小，另一序列的前k/2-1个值 ***可能*** 也比它小，因此， ***至多*** 总共有k-2个值比它小，即，它是第k-1小的值，不可能是第k小的值。  
这样，便找到一种方法，可以使指针快速后移，又确保指针越过的值都不可能是两序列的中位数。  
之后，要考虑一个特殊情况，如果指针移动后会越界，要让指针移动到最后一个元素位置，如果直接不比最后一个位置，不能确保序列尾部的大小情况。  
