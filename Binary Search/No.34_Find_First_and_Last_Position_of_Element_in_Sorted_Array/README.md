## 1.题目
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。  
如果数组中不存在目标值 target，返回 [-1, -1]。  

进阶：  
你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？  

示例 1：  
输入：nums = [5,7,7,8,8,10], target = 8  
输出：[3,4]  

示例 2：  
输入：nums = [5,7,7,8,8,10], target = 6  
输出：[-1,-1]  

示例 3：  
输入：nums = [], target = 0  
输出：[-1,-1]  

---

## 2.分析
此题直观上有两种思路吧：  
&emsp;（1）二分查到target所在位置，往左往右遍历一下，找到左右端点，返回即可  
&emsp;（2）二分查到lower_bound和upper_bound，直接返回  
可以想到，还是法二有更好的时间复杂度，毕竟2次o(logn)的复杂度还是o(logn)，而法一中会涉及到o(n)的复杂度。  

这里，在法二中，涉及到上下界问题，二分处理的方式是与69题非常类似的，值得积累下来。即，最终l与r重合的位置对应的条件是什么，重合位置的左侧对应的条件是什么，理解好这个问题对处理类似的问题很有帮助。  

---

## 3.其它
（1）二分查找时，若是要访问l、r所指元素，一定要先判断其是否存在，因为有可能指针移出了列表范围，处于尾元素的下一个位置。  
（2）有关algorithm库中的[upper_bound()与lower_bound()](https://blog.csdn.net/qq_40160605/article/details/80150252)