## 1.题目
假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。  
请找出其中最小的元素。  
注意数组中可能存在重复的元素。  

示例 1：  
输入: [1,3,5]  
输出: 1  

示例 2：  
输入: [2,2,2,0,1]  
输出: 0  

---

## 2.分析
这个题真的太折磨了！  
拿到此题，我便有了思路，甚至还挺正确的。二分查找最小值所在位置，我们需要思考的就是如何判断出最小值在前一半还是后一半：  
&emsp;如果是左半区间有序，右半区间无序，可以想到，最小值出现在右半区间；  
&emsp;如果是右半区间有序，左半区间无序，可以想到，最小值出现在左半区间；  
想到这里后，我采用的判断区间有序性的方式是拿mid值与l值比较，如果`mid < l`，右半有序；如果`mid > l`，左半有序。  
但是还有个特殊情况，当最后筛选到只剩两个元素时，此时如果`mid < l`，应该返回mid，如果不特殊处理，进行`l = mid + 1`，相当于错过了最小值。反之也是如此。  
但是，我还忽略了一个关键问题，这个序列可以整体有序！虽然我认为这不可能，但是测试数据有这种情况。真的太折磨了。  

但是此题如果不把mid与l比较，反而将mid与r比较，可以大大简化分析过程。  
如果`mid < r`，说明右区间有序，应该遍历左区间，神奇的是，如果整个序列都有序，或是只剩两个元素，都应该遍历其左区间，这真是太神奇了。  
