## 1.题目
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。  
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。  

示例 1：  
输入：nums = [2,0,2,1,1,0]  
输出：[0,0,1,1,2,2]  

示例 2：  
输入：nums = [2,0,1]  
输出：[0,1,2]  

示例 3：  
输入：nums = [0]  
输出：[0]  

示例 4：  
输入：nums = [1]  
输出：[1]  

提示：  
n == nums.length  
1 <= n <= 300  
nums[i] 为 0、1 或 2  

---

## 2.分析
此题其实解决起来很简单，但是题目暗示我们只通过元素之间两两交换的方式来解决，我感觉我对此类问题还是挺陌生的。  
官方题解给出了3种解法，分别是：遍历两次序列，先交换定位好0，再交换定位好1；遍历一次序列，同时定位好0与1；遍历一次序列，同时定位好0与2。  
我在思考后两种解法时遇到了一些困难，但其实后两种解法都是第一种解法的升级版，感觉可以在分析第一种解法时，将交换排序的特征吃透。  

法一：  
如果要把0全部排到序列最前面，首先定义一个指针ptr_0指向下一个存放0的位置，初始化为0，再定义一个ptr遍历整个序列，遇到0就和ptr_0所指元素交换，并且++ptr_0，++ptr，直到ptr遍历完成。思路比较简单，但是具体的：  
如果序列以0起始，那么根据上面的流程，要进行元素0的“原地交换”，之后ptr_0与ptr同步后移1位；如果下一元素还是0，则重复一遍，ptr_0与ptr依旧重合。直到遇到不为0的元素，ptr与ptr_0分开，并且此后，ptr一直领先ptr_0，两指针的差距会在ptr遍历到非0时增大。ptr_0目的是指向下一个填0的位置，其左侧所有元素都是0，而对于ptr_0与ptr之间，由于ptr遍历过的元素，都是被“整理”过的，0都已经置于序列最左侧，因此ptr_0与ptr之间全部非零。（但是当ptr_0与ptr重合时，情况特殊）  
（1）ptr>=ptr_0  
（2）除非ptr=ptr_0，ptr_0指向元素一定非零。  
在遍历完一次之后，0都置于序列左侧，此时1与2还未归位，从ptr_0的位置再次开始遍历，此时可以把ptr_0看作应当置1的位置，如果遍历到1，就与ptr_0所指元素交换。直到遍历完毕。  

法二：
法二感觉是法一的升级版，同时定位0与1的位置，遍历一次。定义ptr_0与ptr_1分别为下个0或1放置的位置，ptr为遍历到的位置，3指针都初始化为0。  
与法一相比，有两个地方比较值得关注：  
（1）最开始，当ptr_0与ptr_1重合时,如果遍历到0，那么ptr_0与ptr_1都要后移。因为ptr_1要大于等于ptr_0。  
（2）当ptr_0与ptr_1不重合，如果遍历到0，那么ptr与ptr_0所指元素交换后，换出来的一定是1，而ptr左侧很有可能有2，因此需要再将ptr与ptr_1所指元素交换，在这个过程后，ptr_0与ptr_1都要后移。  

法三：
这种方法也是只需要ptr遍历一次，同时定位0与2。ptr_0与ptr_2初始值分别位于序列头尾。ptr遍历过的位置，一定是0在左测，1在右侧，没有2。因此如果ptr遍历到0，直接与ptr_0指向元素交换即可，交换之后ptr指向的只有可能为0或1，不会影响已经整理好的部分；如果遍历到2，ptr与ptr_2所指元素交换，换之后，ptr指向可能为0或2，如果此时++ptr，0或2将有可能出现在错误位置。因此对这种情况要特殊处理：若ptr指向0，需再将ptr与ptr_0所指元素交换一次。若ptr指向2，也需将ptr和左移后的ptr_2交换一次，重复直到ptr不再为2。  

直观想法是这样的，具体实现起来可能还会遇到其它细节问题，总之此题比较麻烦和绕，还需多想。