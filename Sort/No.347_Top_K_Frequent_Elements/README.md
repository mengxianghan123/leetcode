## 1.题目
给定一个非空的整数数组，返回其中出现频率前 k 高的元素。  

示例 1:  
输入: nums = [1,1,1,2,2,3], k = 2  
输出: [1,2]  

示例 2:  
输入: nums = [1], k = 1  
输出: [1]  

提示：  
你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。  
你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。  
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。  
你可以按任意顺序返回答案。  

---

## 2.分析
个人感觉这道题其实是为了让我们熟悉unordered_map的数据结构与用法。  
所谓桶结构，就是说，如果很多输入经过哈希函数都映射为1个相同的结果，那么这些结果都被放入一个桶内。这道题想表达的含义就是，数值相同的元素被放入一个桶内，之后比较桶之间所包含元素的多少。  
“数值大小：数值出现次数”就可以构成一个键值对，这种数据结构可以用unordered_map来存储，unordered_map中每个元素的数据结构是pair类型。如果要对unordered_map中的pair进行排序，不能直接用sort进行排序，这里我怀疑是因为unordered_map中只存在单向迭代器。因此需要先将所有的pair拷贝到vector中，再进行sort排序。  
注意到这里题目对时间复杂度有优于O(nlogn)的要求，已知快速排序也只能达到O(nlogn)的要求，因此这里可以采用桶排序。将数值出现次数作为分桶依据，将数值大小入桶，这样只需要由大桶到小桶按顺序取k个数即可。

---

## 3.其它
[C++ STL 之 unordered_set 使用（包括unordersd_map）](https://blog.csdn.net/qq_32172673/article/details/85160180)  
[关于C++ pair 和make_pair的用法](https://blog.csdn.net/weixin_42825576/article/details/81571419)  
[c++中map unordered_map按照value排序几种优雅的写法](https://blog.csdn.net/qq_17550379/article/details/80959968)  
另外，此题也可以采用堆排序和快速选择算法。