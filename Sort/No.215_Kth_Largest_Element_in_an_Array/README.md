## 1.题目
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。  

示例 1:  
输入: [3,2,1,5,6,4] 和 k = 2  
输出: 5  

示例 2:  
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4  
输出: 4  

说明:  
你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。  

---

## 2.分析
首先，有一句说一句，实际项目中如果要实现类似的功能，直接sort+index定位所需的大小是最快的，本题我学会了“快速选择”的算法，但终究提交上去的速度会被直接调库完爆。  
“快速选择”的算法思路，其实来源于快速排序。在快速排序中我们发现，每迭代一次，就可以确定一个数的正确位置，用本题的话来表达，就是确定一个数是第n大的元素。那么这个第n大很可能不是第k大，又由于本次迭代后，该数左侧的值都比其小，右侧的数都比其大，所以便可以根据n与k的大小关系来重新选定下次迭代的区间了。  
如果理解了快速排序的思想，这个“快速选择”真的只是换汤不换药。  

官方题解还介绍了一种堆排序的思路，由于用到了树结构，以后复习到了再翻回来看。  

---

## 3.其它
官方题解在处理快速排序的一次迭代上，算法实现与之前我写到的不同，感觉十分清晰和巧妙，这里[引用](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/)一下。  
```
inline int partition(vector<int>& a, int l, int r) {
        int x = a[r], i = l - 1;
        for (int j = l; j < r; ++j) {
            if (a[j] <= x) {
                swap(a[++i], a[j]);
            }
        }
        swap(a[i + 1], a[r]);
        return i + 1;
    }
```