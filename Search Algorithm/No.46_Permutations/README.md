## 1.题目
给定一个 没有重复 数字的序列，返回其所有可能的全排列。  

示例:  
输入: [1,2,3]  
输出:  
```
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```  

---

## 2.分析
这道题帮助我第一次认识回溯算法，用了不少时间来理解和消化。  
其中对我帮助最大的题解是[代码随想录](https://leetcode-cn.com/problems/permutations/solution/46-quan-pai-lie-hui-su-suan-fa-jing-dian-ti-mu-xia/)和[官方题解](https://leetcode-cn.com/problems/permutations/solution/quan-pai-lie-by-leetcode-solution-2/)  

首先我们可以把排列问题考虑成，有一个空序列，填入给定序列的元素，统计出所有的填法。  
便可以想到一个比较直观的递归思路：维护一个向量used来统计没有用到的元素，每次填元素时都从没有用到的元素中选择。  
假如没有用到的元素为[1,2,3,4]，那么我可以先选择填1，更改used向量，再填后续的空位。当后续空位填完，我还需重新选择在同样的位置填2，重复以上。也就是说，我需要记住当前的选择，然后递归，之后再 **回溯** 回来，切换到下一种情况。如果used序列只剩一个元素没有用到了，也就是所填空序列只剩最后一个位置，说明此次递归可以返回，递归的主调函数需要切换到下种选择。如果所有选择都已经递归完，同样说明此递归可以返回，递归的主调函数需要切换到下种选择。  
此种方法比较直观，不足在于需要额外维护used向量，官方题解还提供了一种空间复杂度更佳的方案。  

此种方案不需要used向量来存储哪些元素用过，哪些没用过，而是考虑将nums向量本身划分为 [用过|没用过] 两部分。对于一个空位，要在所有没用过的元素中选择，也就是要将nums的相应位置与该位置及其后面的位置进行交换。比如序列[1,2,3,4,5]，1和2我已经排列好，3，4，5没有用过，那对于3这个位置，可以用3与3或4或5进行交换来定下用谁来填此位置，之后再递归后续位置。当递归返回，我还需要再交换回来，以便重新交换，选择填在该位置的下个元素。  
此种方法在理解了法一后也不难理解了，实现起来也比较简洁，但是没有经验的情况下不容易想到。  
