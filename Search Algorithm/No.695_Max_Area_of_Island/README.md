## 1.题目
给定一个包含了一些 0 和 1 的非空二维数组 grid 。  
一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。  
找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)  

示例 1:  
```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
 ```  
对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。  

示例 2:  
```
[[0,0,0,0,0,0,0,0]]
```  
对于上面这个给定的矩阵, 返回 0。  

注意: 给定的矩阵grid 的长度和宽度都不超过 50。  

---

## 2.分析
还记得当时学《数据结构》时，老师每个搜索问题都会用递归和栈两种方式来解，现在又体会了一次，递归和栈确实在思想上是相通的。  

首先用递归来解：  
此问题的递归思路为，我如果要遍历相连的所有1，当我拿到一个1时，我需要做的是，在这个1的基础上，遍历1的上下左右。当我遍历了一个1以及其上下左右，就遍历了所有相连的1。  
确定了递归思路，还需要想一下递归终止条件，这个条件往往写在递归内容之前。因为假若递归条件不成立，就不能递归，会报错。比如前序遍历一棵树，当节点为空，我肯定不能再遍历其左子树和右子树。对于这道题，如果我拿到的数为0或者越界了，我肯定也不能继续遍历其上下左右，而是应该返回。  
确定了递归终止条件以及递归的思路，写出一个递归就很容易了。此题需要求解最大的连续1的个数，因此递归过程结束后，需要得到1的个数。我采用的办法是建立一个变量count的引用，count的引用也作为递归函数的一个参数。递归函数每次调用都++count，因此可以做到跟踪1的数量。还有一种办法是用递归函数的返回值来记录，对于一次递归，其返回的1的个数是1+遍历上下左右后返回的1的个数，这种解法也更符合递归的思想。  

对于堆栈的解法：  
核心思路是，当一个1出栈，就将其相邻的1入栈，循环直到空栈。思路不难，但是有个地方值得注意，究竟在什么时候把一个1改为0？出栈还是入栈有影响吗？我起初是在每个1出栈时将其置零，但是后面发现，这样会造成1的重复入栈（这里值得好好想想）。所以只能在1入栈后就马上将其置零。  

---

## 3.其它
[C++中stack的使用方法](https://blog.csdn.net/phdongou/article/details/114248412)